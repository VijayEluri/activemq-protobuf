/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
options {
STATIC=false;
}

PARSER_BEGIN(ProtoParser)
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.activemq.protobuf.compiler.parser;

import org.apache.activemq.protobuf.compiler.*;
import java.util.LinkedHashMap;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.io.File;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;

/**
 * This class is generated with JavaCC. Do not modify manually.
 */
public class ProtoParser {
}

PARSER_END(ProtoParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN :
{
  "//" : COMMENT
}

<COMMENT> SPECIAL_TOKEN :
{
  <("\n" | "\r" | "\r\n" )> : DEFAULT
}

<COMMENT> MORE :
{
  <~[]>
}

TOKEN :
{
    <IMPORT:"import">
  | <PACKAGE:"package">
  | <SERVICE:"service">
  | <RPC:"rpc">
  | <OPTION:"option">
  | <MESSAGE:"message">
  | <EXTENSIONS:"extensions">
  | <EXTEND:"extend">
  | <ENUM:"enum">
  | <GROUP:"group">
  | <REQURIED:"required">
  | <OPTIONAL:"optional">
  | <REPEATED:"repeated">
  | <RETURNS:"returns">
  | <TO:"to">

  | <LBRACE: "{">
  | <RBRACE: "}">
  | <EQUALS: "=">
  | <SEMICOLON: ";">
  | <LBRACKET: "[">
  | <RBRACKET: "]">
  | <LPAREN: "(">
  | <RPAREN: ")">
  | <PERIOD: ".">
  | <COMMA: ",">
  
  | <NUMBER: (["0"-"9"])+>
  | <STRING: "\"" ( ~["\""] )+ "\"">
  | <ID: ["A"-"Z","a"-"z"] (["a"-"z","A"-"Z","0"-"9","_"])*>
}

ProtoDescriptor ProtoDescriptor() :
{
  	ProtoDescriptor proto = new ProtoDescriptor();
	String packageName=null;
    LinkedHashMap<String,OptionDescriptor> opts = new LinkedHashMap<String,OptionDescriptor>();
    LinkedHashMap<String,MessageDescriptor> messages = new LinkedHashMap<String,MessageDescriptor>();
    LinkedHashMap<String,EnumDescriptor> enums = new LinkedHashMap<String,EnumDescriptor>();
    ArrayList<ExtendDescriptor> extendsList = new ArrayList<ExtendDescriptor>();
    LinkedHashMap<String,ServiceDescriptor> services = new LinkedHashMap<String,ServiceDescriptor>();
    ArrayList<String> imports = new ArrayList<String>();
    
    OptionDescriptor optionD;
    MessageDescriptor messageD;
    EnumDescriptor enumD;
    ServiceDescriptor serviceD;
    ExtendDescriptor extendD;
    String o;
}
{
	(
		<PACKAGE> packageName=PackageID() <SEMICOLON>
	)?
    (
        <OPTION> optionD = OptionDescriptor(proto) <SEMICOLON>
        { opts.put(optionD.getName(),optionD); }
    |   
        <IMPORT> 
        o = StringLitteral()
        <SEMICOLON>
        { imports.add((String)o); }
    |   
        messageD = MessageDescriptor(proto) (<SEMICOLON>)?
        { messages.put(messageD.getName(),messageD); }
        
    |   
        enumD = EnumDescriptor(proto) (<SEMICOLON>)?
        { enums.put(enumD.getName(),enumD); }
    |   
        serviceD = ServiceDescriptor(proto) (<SEMICOLON>)?
        { services.put(serviceD.getName(),serviceD); }
    |   
        extendD = ExtendDescriptor(proto) (<SEMICOLON>)?
        { extendsList.add(extendD); }
    )+
    <EOF>
    { 
    	proto.setPackageName(packageName);
    	proto.setOptions(opts);
    	proto.setMessages(messages);
    	proto.setEnums(enums);
    	proto.setServices(services);
    	proto.setExtends(extendsList);
    	return proto; 
    }
}

ServiceDescriptor ServiceDescriptor(ProtoDescriptor proto) :
{
    String name;
    ArrayList<MethodDescriptor> methods = new ArrayList<MethodDescriptor>();
    MethodDescriptor method;
}
{
    <SERVICE> name = ID() <LBRACE>
    (
    	method = MethodDescriptor(proto) <SEMICOLON>
    	{
    		methods.add(method);
    	}
    )*
    <RBRACE> 
    {
    	ServiceDescriptor rc = new ServiceDescriptor(proto);
    	rc.setName(name);
    	rc.setMethods(methods);
    	return rc;
    }
}

MethodDescriptor MethodDescriptor(ProtoDescriptor proto) :
{
    String name;
    String input;
    String output;
}
{
    <RPC> name = ID() <LPAREN> input = PackageID() <RPAREN> <RETURNS> <LPAREN> output = PackageID() <RPAREN>    
    {
    	MethodDescriptor rc = new MethodDescriptor(proto);
    	rc.setName(name);
    	rc.setParameter(input);
    	rc.setReturns(output);
    	return rc;
    }
}

OptionDescriptor OptionDescriptor(ProtoDescriptor proto) :
{
    String name;
    String value;
}
{
    name = ID() 
    <EQUALS> 
    value=Value() 
    {
    	OptionDescriptor rc = new OptionDescriptor(proto);
    	rc.setName(name);
    	rc.setValue(value);
    	return rc;
    }
}

ExtendDescriptor ExtendDescriptor(ProtoDescriptor proto) :
{
    String name;
    LinkedHashMap<String, FieldDescriptor> fields = new LinkedHashMap<String,FieldDescriptor>();
    FieldDescriptor fieldD;
}
{
    <EXTEND> name = ID() <LBRACE>
    (
    	fieldD = FieldDescriptor(proto)
    	{ fields.put(fieldD.getName(), fieldD); }
    )*
    <RBRACE>
    {
    	ExtendDescriptor rc = new ExtendDescriptor(proto);
    	rc.setName(name);
    	rc.setFields(fields);
    	return rc;
    }
}

MessageDescriptor MessageDescriptor(ProtoDescriptor proto) :
{
    String name;
    LinkedHashMap<String,FieldDescriptor> fields = new LinkedHashMap<String,FieldDescriptor>();
    LinkedHashMap<String,MessageDescriptor> messages = new LinkedHashMap<String,MessageDescriptor>();
    LinkedHashMap<String,EnumDescriptor> enums = new LinkedHashMap<String,EnumDescriptor>();
    ArrayList<ExtendDescriptor> extendsList = new ArrayList<ExtendDescriptor>();

    ExtensionsDescriptor extensionsD=null;
	FieldDescriptor fieldD;
	MessageDescriptor messageD;
	EnumDescriptor enumD;
	ExtendDescriptor extendD;
}
{
    <MESSAGE> name = ID() <LBRACE>
    (
    	fieldD = FieldDescriptor(proto) <SEMICOLON>
    	{ fields.put(fieldD.getName(), fieldD); }
    |   
        messageD = MessageDescriptor(proto) (<SEMICOLON>)?
        { messages.put(messageD.getName(),messageD); }
    |   
        enumD = EnumDescriptor(proto) (<SEMICOLON>)?
        { enums.put(enumD.getName(), enumD); }
    |   
        extensionsD = ExtensionsDescriptor(proto) <SEMICOLON>
    |   
        extendD = ExtendDescriptor(proto) (<SEMICOLON>)?
        { extendsList.add(extendD); }
    )*
    <RBRACE>
    {
    	MessageDescriptor rc = new MessageDescriptor(proto);
    	rc.setName(name);
    	rc.setFields(fields);
    	rc.setMessages(messages);
    	rc.setEnums(enums);
    	rc.setExtensions(extensionsD);
    	return rc;
    }
}

ExtensionsDescriptor ExtensionsDescriptor(ProtoDescriptor proto) :
{
	int first;
	int last;
}
{
    <EXTENSIONS> 
    first = Integer() 
    <TO> 
    last = Integer() 
    {
    	ExtensionsDescriptor rc = new ExtensionsDescriptor(proto);
    	rc.setFirst(first);
    	rc.setLast(last);
    	return rc;
    }
}

EnumDescriptor EnumDescriptor(ProtoDescriptor proto) :
{
    Token name;
    LinkedHashMap<String,EnumFieldDescriptor> fields = new LinkedHashMap<String,EnumFieldDescriptor>();
    EnumFieldDescriptor enumD;
}
{
    <ENUM> name = <ID> <LBRACE>
    (
    	enumD = EnumFieldDescriptor(proto) <SEMICOLON>
    	{
    		fields.put(enumD.getName(),enumD);
    	}
    )*
    <RBRACE>
    {
    	EnumDescriptor rc = new EnumDescriptor(proto);
    	rc.setName(name.image);
    	rc.setFields(fields);
    	return rc;
    }
}

/**
 * Parses something like:
 * optional string foo = 1;
 */
EnumFieldDescriptor EnumFieldDescriptor(ProtoDescriptor proto) :
{
    String name;
    int value=0;
}
{

    name = ID()
    <EQUALS>
    value = Integer()
    {
    	EnumFieldDescriptor rc = new EnumFieldDescriptor(proto);
    	rc.setName(name);
    	rc.setValue(value);
    	return rc;
    }
}

/**
 * Parses something like:
 * optional string foo = 1;
 */
FieldDescriptor FieldDescriptor(ProtoDescriptor proto) :
{
    String rule;
    String type;
    String name;
    int tag;
    LinkedHashMap<String,OptionDescriptor> opts = new LinkedHashMap<String,OptionDescriptor>();
    OptionDescriptor optionD;
}
{

    rule = Rule()
    type = PackageID()
    name = ID()
    <EQUALS>
    tag = Integer()
    (
    	<LBRACKET>
    	optionD = OptionDescriptor(proto)
    	{
    		opts.put(optionD.getName(), optionD);
    	}
    	(
    		<COMMA>
	    	optionD = OptionDescriptor(proto)
	    	{
    			opts.put(optionD.getName(), optionD);
    		}
    	)*
    	<RBRACKET>
    )?    
    {
    	FieldDescriptor rc = new FieldDescriptor(proto);
    	rc.setName(name);
    	rc.setType(type);
    	rc.setRule(rule);
    	rc.setTag(tag);
    	rc.setOptions(opts);
    	return rc;
    }
}

int Integer() :
{
    Token t;
}
{
  	t = <NUMBER>
    {
    	return Integer.parseInt(t.image);
    }
}


String Rule() :
{
    Token t;
}
{
    (
    	t = <REQURIED>
    	|
    	t = <OPTIONAL>
    	|
    	t = <REPEATED>
    )
    {
    	return t.image;
    }
}

String Value() :
{
    String value=null;
}
{
    (
    	value = StringLitteral()
    	|
  		value = ID()
    )
    {
    	return value;
    }
}

String ID() :
{
    Token t;
}
{
    (
          t = <ID>
        | t = <IMPORT>
        | t = <PACKAGE>
        | t = <SERVICE>
        | t = <RPC>
        | t = <OPTION>
        | t = <MESSAGE>
        | t = <EXTENSIONS>
        | t = <EXTEND>
        | t = <ENUM>
        | t = <GROUP>
        | t = <REQURIED>
        | t = <OPTIONAL>
        | t = <REPEATED>
        | t = <RETURNS>
        | t = <TO>
    )
    {
    	return t.image;
    }
}

String PackageID() :
{
    String t;
    StringBuffer sb = new StringBuffer();
}
{
    t = ID()
    {
    	sb.append(t);
    }
    (
    	<PERIOD>
    	t=ID()
    	{
    		sb.append(".");
    		sb.append(t);
    	}
    )* 
    {
	    return sb.toString();
    }    
}


String StringLitteral() :
{
    Token t;
}
{
    t = <STRING> 
    {
	    return ParserSupport.decodeString(t.image);
    }    
}
